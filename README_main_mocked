Este documento detalha o funcionamento e os blocos de c√≥digo do script Python main_mocked_v01.py.
Este script simula a coleta de dados de sensores (BME280 e luminosidade), realiza a m√©dia dos valores a cada 5 minutos e os insere em um banco de dados MySQL/MariaDB. Ele opera continuamente, sendo gerenciado pelo servi√ßo raspcollect.service.

üß± 1. Importa√ß√µes e Leitura do RCID
Python

import os
import time
import statistics
import pymysql
import logging
import random

# ============================================
# LEITURA DO RCID (ID DA ESTACAO)
# ============================================
def get_rcid():
    try:
        path = os.path.expanduser("~/.config/station/rcid.txt") 
        with open(path, "r") as f:
            return int(f.read().strip())
    except Exception as e:
        print(f"Erro ao ler rcID: {e}")
        return None

Importa√ß√µes: Inclui as bibliotecas essenciais:

os: Para manipula√ß√£o de caminhos de sistema (especialmente para encontrar o arquivo rcid.txt).

time: Para gerenciamento do loop e do intervalo de 5 minutos.

statistics: Usado para calcular a m√©dia dos dados coletados.

pymysql: O driver Python para comunica√ß√£o com o banco de dados.

logging: Para registrar o status e erros do script.

random: Usado exclusivamente nas fun√ß√µes MOCK para gerar dados aleat√≥rios.

get_rcid(): Fun√ß√£o crucial que l√™ o identificador √∫nico da esta√ß√£o (rcID) do arquivo ~/.config/station/rcid.txt, criado pelo instalador. Este ID √© usado em todas as inser√ß√µes de dados no banco.

üß± 2. Fun√ß√µes de MOCK (Simula√ß√£o de Sensores)

# ============================================
# MOCK DO SENSOR BME280
# ============================================
def read_bme280():
    # ... gera temp, hum e press aleat√≥rias
    return temp, hum, press

# ============================================
# MOCK DE SENSOR DE LUMINOSIDADE
# ============================================
def read_luminosity():
    return random.uniform(0, 1000)

Simula√ß√£o de Leitura: Estas fun√ß√µes utilizam o m√≥dulo random para simular as leituras de sensores.

read_bme280(): Retorna uma tupla com valores aleat√≥rios de Temperatura, Umidade e Press√£o, dentro de faixas realistas.

read_luminosity(): Retorna um valor aleat√≥rio de luminosidade.

Nota: Na transi√ß√£o para produ√ß√£o, estas fun√ß√µes devem ser substitu√≠das pelo c√≥digo real de leitura do hardware (ex: usando a biblioteca adafruit-circuitpython-bme280).

üß± 3. Filtro de Valores Inv√°lidos

# ============================================
# FILTRO DE VALORES INVALIDOS
# ============================================
def is_valid(temp, hum, press, lum):
    if temp is None or temp == 0 or temp < -20 or temp > 50:
        return False
    # ... outras valida√ß√µes (Humidade, Press√£o, Luminosidade)
    return True

Controle de Qualidade: Esta fun√ß√£o implementa um filtro de dados. Antes de adicionar qualquer leitura ao buffer (lista de dados), ela verifica se os valores se encontram dentro de limites f√≠sicos aceit√°veis (ex: temperatura entre -20¬∞C e 50¬∞C).

Fun√ß√£o no Ciclo de Vida: Isso impede que leituras err√°ticas ou falhas moment√¢neas do sensor (que resultariam em None ou zero) contaminem a m√©dia enviada ao banco de dados.

üß± 4. Configura√ß√£o e Conex√£o com o Banco de Dados

# ============================================
# CONEXAO COM O BANCO MARIADB
# ============================================
# PLACEHOLDERS SER√ÉO SUBSTITU√çDOS PELO INSTALADOR
DB_HOST = "DB_HOST_PLACEHOLDER"
DB_USER = "DB_USER_PLACEHOLDER"
DB_PASS = "DB_PASS_PLACEHOLDER"
DB_NAME = "DB_NAME_PLACEHOLDER"

def db_connect():
    return pymysql.connect(
        host=DB_HOST,
        user=DB_USER,
        password=DB_PASS,
        database=DB_NAME
    )

Placeholders: As vari√°veis de conex√£o (DB_HOST, DB_USER, etc.) est√£o inicialmente com valores placeholder. O instalador em Bash (installstation_v01.sh) √© respons√°vel por substituir estas strings pelas credenciais reais antes de iniciar o script.

db_connect(): Fun√ß√£o que retorna uma nova conex√£o com o banco de dados MariaDB/MySQL usando o driver pymysql e as credenciais injetadas. A conex√£o √© aberta apenas quando √© necess√°rio (no momento de inserir a m√©dia).

üß± 5. Loop Principal de Coleta (main)

# ============================================
# LOOP PRINCIPAL DE COLETA
# ============================================
def main():
    # ... Inicializa√ß√£o: rcID, buffers (m_temp, m_hum, etc.), last_send
    while True:
        # 1. Leitura dos MOCKs
        bme = read_bme280()
        luminosity = read_luminosity()
        
        # 2. Valida√ß√£o e Ac√∫mulo no Buffer
        if is_valid(temp, hum, press, luminosity):
            m_temp.append(temp)
            # ... acumulando outros dados
        
        # 3. Condi√ß√£o de Envio (A CADA 5 MINUTOS = 300 segundos)
        if time.time() - last_send >= 300:
            if len(m_temp) > 0:
                # 4. C√°lculo da M√©dia
                avg_temp = round(statistics.mean(m_temp), 2)
                # ... c√°lculo de outras m√©dias
                
                # 5. Inser√ß√£o no Banco
                try:
                    conn = db_connect()
                    cursor = conn.cursor()
                    cursor.execute(""" INSERT INTO Raspdata (rcID, Temp, Humidity, Pressure, Light) ... """,
                                   (rcID, avg_temp, avg_hum, avg_press, avg_lum))
                    conn.commit()
                    conn.close()
                except Exception as e:
                    logging.error(f"Erro ao inserir no banco: {e}")
                
                # 6. Reset
                m_temp.clear()
                # ... clear outros buffers
                last_send = time.time()
            
        time.sleep(10) # Pausa de 10 segundos entre cada leitura

Inicializa√ß√£o: A fun√ß√£o principal inicializa as listas vazias (m_temp, m_hum, etc.) que servem como buffers para acumular leituras e a vari√°vel last_send (marcando o tempo da √∫ltima inser√ß√£o).

Ciclo de Leitura: O while True garante que o script rode continuamente:

Leitura e Valida√ß√£o: A cada itera√ß√£o (loop), os mocks s√£o chamados, e os valores s√£o acumulados nos buffers apenas se passarem pelo filtro is_valid().

Intervalo de Envio: O if time.time() - last_send >= 300: verifica se 5 minutos (300 segundos) se passaram desde o √∫ltimo envio.

Agrega√ß√£o: Se for hora de enviar, a m√©dia aritm√©tica (statistics.mean) de cada buffer √© calculada e arredondada.

Transa√ß√£o DB: √â feita uma nova conex√£o, a query INSERT √© executada com os valores m√©dios, a transa√ß√£o √© confirmada (conn.commit()) e a conex√£o √© fechada.

Limpeza: Os buffers de dados s√£o esvaziados (clear()) e last_send √© atualizado para iniciar um novo ciclo de 5 minutos.

time.sleep(10): Define o intervalo entre cada leitura individual do sensor em 10 segundos. 
O script far√° aproximadamente 30 leituras v√°lidas antes de calcular a m√©dia e enviar os dados.
